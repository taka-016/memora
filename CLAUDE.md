# CLAUDE.md

## プロジェクト概要

**このアプリ（memora）について**
- ユーザーが家族などのグループ内での過去と未来のイベントを記録・共有できるアプリケーション
- メイン機能は以下の情報を年表形式で俯瞰する画面
    - グループのイベント・旅行
    - 個人のイベント
- メンバーの管理画面があり、メンバーの追加・削除・情報更新ができる
- メンバーとグループという概念があり、グループに1人以上のメンバーが所属する
- メンバーは所属するグループを設定するが、必須ではない
- メンバーは複数のグループに所属することが可能
- メンバーに紐づけて登録できるデータは以下
    - イベント（member_event）
- グループに紐づいて登録できるデータは以下
    - 旅行情報（trip_entry）
    - イベント（group_event）
- 旅行情報（trip_entry）には位置情報（pin）が紐づく
- 位置情報（pin）はGoogle Maps上にピン留めして作成することができ、訪問日やメモを追加することができる
- 旅行の参加者（trip_participant）はグループ外のメンバーも含めることができる

**設計資料**
- ER図: doc/er_diagram.md
- ユースケース図: doc/usecase_diagram.md
- todo: doc/todo.md

**主要コマンド**
- `flutter run` - アプリケーションを実行
- `flutter pub get` - 依存関係をインストール
- `flutter pub run build_runner build --delete-conflicting-outputs` - モックやコード生成を実行
- `./check.sh` - フォーマット・解析・テストを一括実行
- `flutter analyze` - 静的コード解析
- `dart format .` - コードフォーマット
- `flutter test` - 全テストを実行
- `flutter test test/unit/` - ユニットテストのみ実行
- `flutter test test/integration/` - インテグレーションテストを実行
- `tree lib test` - アプリケーションとテストのディレクトリ構造を表示

## アーキテクチャ
※Robert C.Martinが提唱した**クリーンアーキテクチャ**に従います。

### クリーンアーキテクチャの原則
- **依存関係逆転の原則**: 外側の層が内側の層に依存し、内側の層は外側の層を知らない
- **関心の分離**: 各層は明確に分離された責任を持つ
- **テスタビリティ**: フレームワークやデータベースに依存しない設計
- **独立性**: ビジネスルールは外部要因から独立している

### 4つのレイヤー構成

#### 1. エンティティ層 (`lib/domain/entities/`)
- **エンタープライズビジネスルール**を含む
- アプリケーション全体で最も重要なビジネスルール
- 外部の変更による影響を最も受けにくい
- データ構造とそれに関連する基本的なビジネスルールを定義

#### 2. ユースケース層 (`lib/application/usecases/`)
- **アプリケーション固有のビジネスルール**を含む
- システムのすべてのユースケースをカプセル化・実装
- エンティティとの間でデータの流れを調整
- データベースやUIの変更に影響されない

#### 3. インターフェースアダプター層 (`lib/infrastructure/`)
- **データ変換**を担当
- ユースケースやエンティティに便利な形式と、データベースやWebなどの外部機関に便利な形式の間でデータを変換
- **repositories:** データアクセス抽象化の具体実装
- **services:** 外部サービスの具体実装
- **mappers:** レイヤー間のデータ変換

#### 4. フレームワーク・ドライバー層 (`lib/presentation/`)
- **外部とのインターフェース**を担当
- UI、データベース、Webフレームワークなど
- **widgets:** 再利用可能なUIコンポーネント
- **auth:** 認証関連のUI
- **top_page.dart:** トップページのUI（常にトップページを表示し、メニュー選択に応じてwidgetsを切り替える）

### 抽象化レイヤー (`lib/domain/repositories/`, `lib/domain/services/`)
- インターフェースアダプター層の具体実装に対する抽象インターフェース
- 依存関係逆転の原則を実現するための境界

### 状態管理 (`lib/application/managers/`)
- アプリケーション状態を管理
- ユースケース層との橋渡し役

## TDDワークフロー定義
※Kent Beckの原著『Test-Driven Development: By Example』とその翻訳者であるt-wadaの解釈に従います。

### TDDの基本概念
テスト駆動開発（TDD）は、**まずテストを書き、それを通すコードを書く**という開発手法です。
「動作するきれいなコード」を効率的に実現するための手法として、Kent Beckによって体系化されました。

### Red - Green - Refactor サイクル

#### 1. **Red（失敗するテストを書く）**
- **新しい機能のための小さなテストを書く**
- テストを実行し、失敗することを確認する（Red）
- 実装コードは一切書かない
- 失敗理由が期待通りであることを確認する

#### 2. **Green（テストを通すコードを書く）**
- **テストを通すための最小限のコードを書く**
- テストを実行し、成功することを確認する（Green）
- 「最小限」を徹底し、テストを通すだけの実装に留める
- 美しさや設計の良さは一旦無視する

#### 3. **Refactor（重複を排除する）**
- **重複を排除し、設計を改善する**
- テストコードと実装コードの両方をリファクタリング対象とする
- リファクタリング後もすべてのテストが通ることを確認する
- 機能追加は行わず、既存コードの改善に専念する

### TDDの三原則（Kent Beck）
1. **失敗するユニットテストを書くまでは、実装コードを書いてはならない**
2. **コンパイルが通らず失敗するユニットテストを書く以上に、ユニットテストを書いてはならない**
3. **現在失敗しているテストを通す以上に、実装コードを書いてはならない**

### TDDのメリット
- **設計の改善**: テスタブルな設計が自然と生まれる
- **リファクタリングの安全性**: テストが設計変更の安全網となる
- **ドキュメント効果**: テストコードが仕様の文書として機能する
- **デバッグ時間の削減**: 問題の早期発見と局所化が可能
- **コードカバレッジの向上**: 書いたコードは必ずテストされる

### TDDで重要な考え方
- **小さなステップ**: 大きな問題を小さく分割して進める
- **仮実装**: まずは定数を返すなど、最小限の実装から始める
- **三角測量**: 複数のテストケースから一般化を行う
- **明白な実装**: 実装が自明な場合は直接書く

## 実装作業の進め方

### 前提条件
- 各作業には文末に「TDDワークフロー定義に従い実装する」が常に省略されている

### 基本ルール
**以下のルールは例外なく守ること。違反は禁止：**

1. **必須**: 常に日本語で会話すること
2. **必須**: ユーザーからの指示に該当する作業が`doc/todo_list.md`に存在しない場合は、**必ず処理を中断**してユーザーに確認すること
3. **必須**: 必ず新しく作業用のブランチを切ること（`CLAUDE.md`の**ブランチ名**に従う）

### 技術的必須事項
**以下は技術的に必須の手順。省略や変更は禁止：**

1. **必須**: すべての作業は`CLAUDE.md`の**TDDワークフロー定義**に従って進めること（例外は認めない）
2. **必須**: 各作業開始前に`tree lib test`でディレクトリ構造を確認すること
3. **必須**: コマンド実行時は&&で繋がず1つずつ実行し、結果を確認しながら進めること
4. **必須**: 作業の最後に`./check.sh`を実行すること

### 作業完了時の必須手順
**以下の作業完了時に必須の手順。順序の変更や省略は禁止：**

1. **必須**: 対応する`doc/todo_list.md`の項目に`[x]`チェックを入れる
2. **必須**: 変更ファイルを`git add`でステージングに追加する
3. **必須**: `CLAUDE.md`の**コミット形式**に従ってコミット&プッシュ&プルリクエストを作成する
4. **必須**: プルリクエストのタイトルと説明に対応する`doc/todo_list.md`の項目を記載する
5. **禁止**: `doc/todo_list.md`のチェックを入れずにコミットすることは絶対に禁止

## コーディング規約
- インデントは2スペース
- 文字列は原則としてシングルクォーテーション使用
- constを積極的に使用する
- 不要なprintはコミット前に削除
- ファイル名・ディレクトリ名はsnake_case
- クラス名はUpperCamelCase
- 変数名・関数名はlowerCamelCase
- 定数はSCREAMING_SNAKE_CASE
- コメントは最小限にし、コードを見ればわかることはコメントしないこと

## ブランチ名
- `feature/` プレフィックスを付けて新機能のブランチ名を作成
- `bugfix/` プレフィックスを付けてバグ修正のブランチ名を作成
- `refactor/` プレフィックスを付けてリファクタリングのブランチ名を作成
- `docs/` プレフィックスを付けてドキュメントの更新ブランチ名を作成
- `test/` プレフィックスを付けてテストの追加・修正
- `chore/` プレフィックスを付けてその他の変更ブランチ名を作成

## コミット形式
- `[feat]` 新機能の概要
- `[fix]` 修正内容の概要
- `[refactor]` リファクタ内容の概要
- `[docs]` ドキュメントの更新内容
- `[test]` テストの追加・修正内容
- `[chore]` その他の変更

## Lint設定
- flutter_lintsパッケージを使用
- analysis_options.yamlでprefer_const_constructors常に有効化、avoid_printエラー扱い

## その他
- 非同期処理にはasync/awaitを使用し、thenチェーンは避ける

## 環境設定
`.env`の環境変数:
- `GOOGLE_PLACES_API_KEY` - 位置検索機能に必要

環境変数の変更後は`flutter pub run build_runner build --delete-conflicting-outputs`を実行してください。

## Firebase設定
アプリはFirestoreを使用してデータを永続化する。
- 設定ファイル:
    - `firebase_options.dart` - 生成されたFirebase設定
    - `firebase.json` - Firebaseプロジェクト設定

## テスト方針
- ユニットテストのディレクトリ構成はlib/と同じにする
- テスト命名はxxx_test.dartとする
- 外部依存関係にはMockitoを使用したモックを使用する
- カバレッジ目標: 80%以上

### テストファイル
- ユニットテスト: `test/unit/`
- インテグレーションテスト: `test/integration/`

### テストベストプラクティス
- **非同期テストの制御**: `Future.delayed`を使った待機は避ける。環境によって不安定になるため、`Completer`を使用してテストコードが非同期処理のタイミングを制御する
  ```dart
  // ❌ 避けるべき方法
  when(mockUseCase.execute()).thenAnswer((_) async {
    await Future.delayed(const Duration(milliseconds: 100));
    return result;
  });
  
  // ✅ 推奨する方法
  final completer = Completer<Result>();
  when(mockUseCase.execute()).thenAnswer((_) => completer.future);
  // テストコードで完了タイミングを制御
  completer.complete(result);
  ```