# CLAUDE.md

## プロジェクト概要

**このアプリ（memora）について**
- ユーザーが家族などのグループ内での過去と未来のイベントを記録・共有できるアプリケーション
- メイン機能は以下の情報を年表形式で俯瞰する画面
    - グループのイベント・旅行
    - 個人のイベント
- メンバーの管理画面があり、メンバーの追加・削除・情報更新ができる
- メンバーとグループという概念があり、グループに1人以上のメンバーが所属する
- メンバーは所属するグループを設定するが、必須ではない
- メンバーは複数のグループに所属することが可能
- メンバーに紐づけて登録できるデータは以下
    - イベント（member_event）
- グループに紐づいて登録できるデータは以下
    - 旅行情報（trip_entry）
    - イベント（group_event）
- 旅行情報（trip_entry）には位置情報（pin）が紐づく
- 位置情報（pin）はGoogle Maps上にピン留めして作成することができ、訪問日やメモを追加することができる
- 旅行の参加者（trip_participant）はグループ外のメンバーも含めることができる

**設計資料**
- ER図: doc/er_diagram.md
- ユースケース図: doc/usecase_diagram.md
- todo: doc/todo.md

**主要コマンド**
- `flutter run` - アプリケーションを実行
- `flutter pub get` - 依存関係をインストール
- `flutter pub run build_runner build --delete-conflicting-outputs` - モックやコード生成を実行
- `./check.sh` - フォーマット・解析・テストを一括実行
- `flutter analyze` - 静的コード解析
- `dart format .` - コードフォーマット
- `flutter test` - 全テストを実行
- `flutter test test/unit/` - ユニットテストのみ実行
- `flutter test test/integration/` - インテグレーションテストを実行

## アーキテクチャ
**クリーンアーキテクチャ**の考え方をベースとし、3つの主要レイヤーで構成しています。

### ドメインレイヤー (`lib/domain/`)
- **entities:** コアビジネスオブジェクト
- **repositories:** データアクセス用の抽象インターフェース
- **services:** 外部サービス用の抽象インターフェース

### アプリケーションレイヤー (`lib/application/`)
- **usecases:** ビジネスロジック実装
- **managers:** アプリケーション状態管理

### インフラストラクチャレイヤー (`lib/infrastructure/`)
- **repositories:** Firebaseを使用した具体的実装
- **services:** 外部サービス実装
- **mappers:** レイヤー間のデータ変換

### プレゼンテーションレイヤー (`lib/presentation/`)
- **widgets:** 再利用可能なUIコンポーネント
- **auth:** 認証関連のUI
- **top_page.dart:** トップページのUI（常にトップページを表示し、メニュー選択に応じてwidgetsを切り替える）

## TDDワークフロー定義
1. **Red:**
    - Redフェーズは実装コードを書かない。
    - 目的を満たすためのテストコードを書く。
    - テストを実行し、テストが失敗することを確認する。
2. **Green:**
    - 必要最小限の実装コードを書く。
    - テストを実行し、テストが通ることを確認する。
3. **Refactor:**
    - コードを整理し、リファクタリングする。
    - テストを実行し、テストが引き続き通ることを確認する。

## 作業の進め方
- 常に日本語で会話すること
- 作業内容を説明しながら進めること
- コンテキストが不明瞭な時は、ユーザーに質問して確認すること
- 必ず全体の構成を把握してから作業に入ること
- 作業は段階的に進め、各ステップで結果を確認すること
- 実装作業は「TDDワークフロー」に従い、必ずテストコードの作成から始めること
- ユーザーが実装指示するときは、文末に「TDDワークフローに従って実装してください」という言葉が常に省略されていると考えること
- 変更点は最小限に留め、必要な部分のみを修正すること
- 既存のコードを尊重し、変更が必要な場合はその理由を明確にすること
- 作業の前に必ず`doc/todo_list.md`を確認し、ToDoリストに沿って進めること。
- `doc/todo_list.md`はユーザーが管理するため、変更しないこと。
- コマンド実行は1つずつ行い、結果を確認しながら進めること
- 作業の最後に必ず`./check.sh`を実行すること
- コミット前に`./check.sh`を必ず実行すること
- 「作業完了の判定基準」が満たされているかを確認すること

### 品質保証チェックリスト
作業完了前に以下を必ずチェックすること：

#### テストコード品質チェック
- [ ] 作成/修正したすべてのテストが実際に意味のあることをテストしているか
- [ ] 暫定的なテストや「とりあえず通す」テストが残っていないか  
- [ ] モックが適切に設定され、実際のメソッド呼び出しを検証しているか
- [ ] テストケース名が実際のテスト内容と一致しているか
- [ ] 正常系・異常系の両方が適切にテストされているか

#### 実装品質チェック
- [ ] 新しく作成したメソッドや機能にテストが存在するか
- [ ] インターフェースの変更に対応する実装がすべて完了しているか
- [ ] エラーハンドリングが適切に実装されているか
- [ ] コーディング規約に従っているか

#### 統合チェック
- [ ] 修正が他の機能に悪影響を与えていないか（全テストの実行）
- [ ] `./check.sh`でエラーが出ていないか
- [ ] 実装した機能が要求仕様を満たしているか

### 作業完了の判定基準
以下をすべて満たした場合のみ作業完了とする：
1. 品質保証チェックリストの全項目にチェックが入る
2. `./check.sh`が成功する
3. 追加したテストがすべて適切にモック化され、実際の動作を検証している
4. 暫定的なコメントや「TODO」が残っていない
5. ユーザーの要求仕様が完全に満たされている

## コーディング規約
- インデントは2スペース
- 文字列は原則としてシングルクォーテーション使用
- constを積極的に使用する
- 不要なprintはコミット前に削除
- ファイル名・ディレクトリ名はsnake_case
- クラス名はUpperCamelCase
- 変数名・関数名はlowerCamelCase
- 定数はSCREAMING_SNAKE_CASE
- コメントは最小限にし、コードを見ればわかることはコメントしないこと

## コミット形式
- `[feat]` 新機能の概要
- `[fix]` 修正内容の概要
- `[refactor]` リファクタ内容の概要
- `[docs]` ドキュメントの更新内容
- `[test]` テストの追加・修正内容
- `[chore]` その他の変更

## Lint設定
- flutter_lintsパッケージを使用
- analysis_options.yamlでprefer_const_constructors常に有効化、avoid_printエラー扱い

## その他
- 非同期処理にはasync/awaitを使用し、thenチェーンは避ける

## 環境設定
`.env`の環境変数:
- `GOOGLE_PLACES_API_KEY` - 位置検索機能に必要

環境変数の変更後は`flutter pub run build_runner build --delete-conflicting-outputs`を実行してください。

## Firebase設定
アプリはFirestoreを使用してデータを永続化する。
- 設定ファイル:
    - `firebase_options.dart` - 生成されたFirebase設定
    - `firebase.json` - Firebaseプロジェクト設定

## テスト方針
- ユニットテストのディレクトリ構成はlib/と同じにする
- テスト命名はxxx_test.dartとする
- 外部依存関係にはMockitoを使用したモックを使用する
- カバレッジ目標: 80%以上
- `./check.sh`を通過することを必須とする

### テストファイル
- ユニットテスト: `test/unit/`
- インテグレーションテスト: `test/integration/`

### テストベストプラクティス
- **非同期テストの制御**: `Future.delayed`を使った待機は避ける。環境によって不安定になるため、`Completer`を使用してテストコードが非同期処理のタイミングを制御する
  ```dart
  // ❌ 避けるべき方法
  when(mockUseCase.execute()).thenAnswer((_) async {
    await Future.delayed(const Duration(milliseconds: 100));
    return result;
  });
  
  // ✅ 推奨する方法
  final completer = Completer<Result>();
  when(mockUseCase.execute()).thenAnswer((_) => completer.future);
  // テストコードで完了タイミングを制御
  completer.complete(result);
  ```