# CLAUDE.md

## プロジェクト概要

**このアプリ（memora）について**
- ユーザーが家族などのグループ内での過去と未来のイベントを記録・共有できるアプリケーション
- メイン機能は以下の情報を年表形式で俯瞰する画面
    - グループのイベント・旅行
    - 個人のイベント
- メンバーの管理画面があり、メンバーの追加・削除・情報更新ができる
- メンバーとグループという概念があり、グループに1人以上のメンバーが所属する
- メンバーは所属するグループを設定するが、必須ではない
- メンバーは複数のグループに所属することが可能
- メンバーに紐づけて登録できるデータは以下
    - イベント（member_event）
- グループに紐づいて登録できるデータは以下
    - 旅行情報（trip_entry）
    - イベント（group_event）
- 旅行情報（trip_entry）には位置情報（pin）が紐づく
- 位置情報（pin）はGoogle Maps上にピン留めして作成することができ、訪問日やメモを追加することができる
- 旅行の参加者（trip_participant）はグループ外のメンバーも含めることができる

**設計資料**
- ER図: doc/er_diagram.md
- ユースケース図: doc/usecase_diagram.md
- todo: doc/todo.md

**主要コマンド**
- `flutter run` - アプリケーションを実行
- `flutter pub get` - 依存関係をインストール
- `flutter pub run build_runner build --delete-conflicting-outputs` - モックやコード生成を実行
- `./check.sh` - フォーマット・解析・テストを一括実行
- `flutter analyze` - 静的コード解析
- `dart format .` - コードフォーマット
- `flutter test` - 全テストを実行
- `flutter test test/unit/` - ユニットテストのみ実行
- `flutter test test/integration/` - インテグレーションテストを実行
- `tree lib test` - アプリケーションとテストのディレクトリ構造を表示

## アーキテクチャ
※Robert C.Martinが提唱した**クリーンアーキテクチャ**に従います。

### クリーンアーキテクチャの原則
- **依存関係逆転の原則**: 外側の層が内側の層に依存し、内側の層は外側の層を知らない
- **関心の分離**: 各層は明確に分離された責任を持つ
- **テスタビリティ**: フレームワークやデータベースに依存しない設計
- **独立性**: ビジネスルールは外部要因から独立している

### 4つのレイヤー構成

#### 1. エンティティ層 (`lib/domain/entities/`)
- **エンタープライズビジネスルール**を含む
- アプリケーション全体で最も重要なビジネスルール
- 外部の変更による影響を最も受けにくい
- データ構造とそれに関連する基本的なビジネスルールを定義

#### 2. ユースケース層 (`lib/application/usecases/`)
- **アプリケーション固有のビジネスルール**を含む
- システムのすべてのユースケースをカプセル化・実装
- エンティティとの間でデータの流れを調整
- データベースやUIの変更に影響されない

#### 3. インターフェースアダプター層 (`lib/infrastructure/`)
- **データ変換**を担当
- ユースケースやエンティティに便利な形式と、データベースやWebなどの外部機関に便利な形式の間でデータを変換
- **repositories:** データアクセス抽象化の具体実装
- **services:** 外部サービスの具体実装
- **mappers:** レイヤー間のデータ変換

#### 4. フレームワーク・ドライバー層 (`lib/presentation/`)
- **外部とのインターフェース**を担当
- UI、データベース、Webフレームワークなど
- **widgets:** 再利用可能なUIコンポーネント
- **auth:** 認証関連のUI
- **top_page.dart:** トップページのUI（常にトップページを表示し、メニュー選択に応じてwidgetsを切り替える）

### 抽象化レイヤー (`lib/domain/repositories/`, `lib/domain/services/`)
- インターフェースアダプター層の具体実装に対する抽象インターフェース
- 依存関係逆転の原則を実現するための境界

### 状態管理 (`lib/application/managers/`)
- アプリケーション状態を管理
- ユースケース層との橋渡し役

## TDDワークフロー定義
※Kent Beckの原著『Test-Driven Development: By Example』とその翻訳者であるt-wadaの解釈に従います。

### TDDの基本概念
テスト駆動開発（TDD）は、**まずテストを書き、それを通すコードを書く**という開発手法です。
「動作するきれいなコード」を効率的に実現するための手法として、Kent Beckによって体系化されました。

### Red - Green - Refactor サイクル

#### 1. **Red（失敗するテストを書く）**
- **新しい機能のための小さなテストを書く**
- テストを実行し、失敗することを確認する（Red）
- 実装コードは一切書かない
- 失敗理由が期待通りであることを確認する

#### 2. **Green（テストを通すコードを書く）**
- **テストを通すための最小限のコードを書く**
- テストを実行し、成功することを確認する（Green）
- 「最小限」を徹底し、テストを通すだけの実装に留める
- 美しさや設計の良さは一旦無視する

#### 3. **Refactor（重複を排除する）**
- **重複を排除し、設計を改善する**
- テストコードと実装コードの両方をリファクタリング対象とする
- リファクタリング後もすべてのテストが通ることを確認する
- 機能追加は行わず、既存コードの改善に専念する

### TDDの三原則（Kent Beck）
1. **失敗するユニットテストを書くまでは、実装コードを書いてはならない**
2. **コンパイルが通らず失敗するユニットテストを書く以上に、ユニットテストを書いてはならない**
3. **現在失敗しているテストを通す以上に、実装コードを書いてはならない**

### TDDのメリット
- **設計の改善**: テスタブルな設計が自然と生まれる
- **リファクタリングの安全性**: テストが設計変更の安全網となる
- **ドキュメント効果**: テストコードが仕様の文書として機能する
- **デバッグ時間の削減**: 問題の早期発見と局所化が可能
- **コードカバレッジの向上**: 書いたコードは必ずテストされる

### TDDで重要な考え方
- **小さなステップ**: 大きな問題を小さく分割して進める
- **仮実装**: まずは定数を返すなど、最小限の実装から始める
- **三角測量**: 複数のテストケースから一般化を行う
- **明白な実装**: 実装が自明な場合は直接書く

## 作業の進め方
- 常に日本語で会話すること
- 作業内容を説明しながら進めること
- コンテキストが不明瞭な時は、ユーザーに質問して確認すること
- `tree lib test`でディレクトリ構造を確認し、必要なファイルを特定すること
- 作業は段階的に進め、各ステップで結果を確認すること
- 実装作業は**TDDワークフロー定義**に従い、必ずテストコードの作成から始めること
- ユーザーが実装指示するときは、文末に「TDDワークフロー定義に従って実装してください」という言葉が常に省略されていると考えること
- 変更点は最小限に留め、必要な部分のみを修正すること
- 既存のコードを尊重し、変更が必要な場合はその理由を明確にすること
- 作業の前に必ず`doc/todo_list.md`を確認し、ToDoリストに沿って進めること。
- `doc/todo_list.md`はユーザーが管理するため、変更しないこと。
- コマンド実行は1つずつ行い、結果を確認しながら進めること
- 作業の最後に必ず`./check.sh`を実行すること
- コミット前に`./check.sh`を必ず実行すること
- 「作業完了の判定基準」が満たされているかを確認すること

### 品質保証チェックリスト
作業完了前に以下を必ずチェックすること：

#### テストコード品質チェック
- [ ] 作成/修正したすべてのテストが実際に意味のあることをテストしているか
- [ ] 暫定的なテストや「とりあえず通す」テストが残っていないか  
- [ ] モックが適切に設定され、実際のメソッド呼び出しを検証しているか
- [ ] テストケース名が実際のテスト内容と一致しているか
- [ ] 正常系・異常系の両方が適切にテストされているか

#### 実装品質チェック
- [ ] 新しく作成したメソッドや機能にテストが存在するか
- [ ] インターフェースの変更に対応する実装がすべて完了しているか
- [ ] エラーハンドリングが適切に実装されているか
- [ ] コーディング規約に従っているか

#### 統合チェック
- [ ] 修正が他の機能に悪影響を与えていないか（全テストの実行）
- [ ] `./check.sh`でエラーが出ていないか
- [ ] 実装した機能が要求仕様を満たしているか

### 作業完了の判定基準
以下をすべて満たした場合のみ作業完了とする：
1. 品質保証チェックリストの全項目にチェックが入る
2. `./check.sh`が成功する
3. 追加したテストがすべて適切にモック化され、実際の動作を検証している
4. 暫定的なコメントや「TODO」が残っていない
5. ユーザーの要求仕様が完全に満たされている

## コーディング規約
- インデントは2スペース
- 文字列は原則としてシングルクォーテーション使用
- constを積極的に使用する
- 不要なprintはコミット前に削除
- ファイル名・ディレクトリ名はsnake_case
- クラス名はUpperCamelCase
- 変数名・関数名はlowerCamelCase
- 定数はSCREAMING_SNAKE_CASE
- コメントは最小限にし、コードを見ればわかることはコメントしないこと

## コミット形式
- `[feat]` 新機能の概要
- `[fix]` 修正内容の概要
- `[refactor]` リファクタ内容の概要
- `[docs]` ドキュメントの更新内容
- `[test]` テストの追加・修正内容
- `[chore]` その他の変更

## Lint設定
- flutter_lintsパッケージを使用
- analysis_options.yamlでprefer_const_constructors常に有効化、avoid_printエラー扱い

## その他
- 非同期処理にはasync/awaitを使用し、thenチェーンは避ける

## 環境設定
`.env`の環境変数:
- `GOOGLE_PLACES_API_KEY` - 位置検索機能に必要

環境変数の変更後は`flutter pub run build_runner build --delete-conflicting-outputs`を実行してください。

## Firebase設定
アプリはFirestoreを使用してデータを永続化する。
- 設定ファイル:
    - `firebase_options.dart` - 生成されたFirebase設定
    - `firebase.json` - Firebaseプロジェクト設定

## テスト方針
- ユニットテストのディレクトリ構成はlib/と同じにする
- テスト命名はxxx_test.dartとする
- 外部依存関係にはMockitoを使用したモックを使用する
- カバレッジ目標: 80%以上

### テストファイル
- ユニットテスト: `test/unit/`
- インテグレーションテスト: `test/integration/`

### テストベストプラクティス
- **非同期テストの制御**: `Future.delayed`を使った待機は避ける。環境によって不安定になるため、`Completer`を使用してテストコードが非同期処理のタイミングを制御する
  ```dart
  // ❌ 避けるべき方法
  when(mockUseCase.execute()).thenAnswer((_) async {
    await Future.delayed(const Duration(milliseconds: 100));
    return result;
  });
  
  // ✅ 推奨する方法
  final completer = Completer<Result>();
  when(mockUseCase.execute()).thenAnswer((_) => completer.future);
  // テストコードで完了タイミングを制御
  completer.complete(result);
  ```